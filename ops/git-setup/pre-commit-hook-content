#!/usr/bin/env bash

# Check the branch name for compatibility with Jira tickets
local_branch="$(git rev-parse --abbrev-ref HEAD)"
may_be_cams_regex="^[cC][aA][mM][sS].*$"
preferred_branch_prefix_regex="^CAMS-[0-9]+-.*$"

message="In order for Jira to associate your branch name with a ticket, the branch name must start with 'CAMS-' followed by the ticket number. You should rename your branch to a valid name and try again."
branch_accepted=false

if [[ $local_branch =~ $may_be_cams_regex ]]
then
    if [[ $local_branch =~ $preferred_branch_prefix_regex ]]
    then
        branch_accepted=true
    else
        branch_accepted=false
    fi
else
    branch_accepted=true
fi

if [[ $branch_accepted == false ]]
then
    echo "${message}"
    exit 1
fi

# Check if source code files were changed without test files
# Get list of staged files
staged_files=$(git diff --cached --name-only)

# Check if any source code files were modified
source_files_changed=false
test_files_changed=false

for file in $staged_files; do
    # Check if file is a source code file (ts, tsx, js, jsx)
    if [[ $file =~ \.(ts|tsx|js|jsx)$ && ! $file =~ \.test\.(ts|tsx|js|jsx)$ && ! $file =~ \.d\.ts$ && ! $file =~ \.config\.ts$ ]]; then
        source_files_changed=true
    # Check if file is a test file
    elif [[ $file =~ \.test\.(ts|tsx|js|jsx)$ ]]; then
        test_files_changed=true
    else
        # Any other file type is considered a non-source file
        :
    fi
done

# If source files changed but no test files changed
if [[ $source_files_changed == true && $test_files_changed == false ]]; then
    echo "⚠️  Warning: You've modified source code files but no test files."
    echo "Modified source files:"
    for file in $staged_files; do
        if [[ $file =~ \.(ts|tsx|js|jsx)$ && ! $file =~ \.test\.(ts|tsx|js|jsx)$ && ! $file =~ \.d\.ts$ ]]; then
            echo "  - $file"
        fi
    done

    # Use </dev/tty to ensure read gets input from the terminal even in non-interactive environments
    if [ -t 0 ]; then
        # Terminal is interactive
        read -p "Are you sure you want to commit without updating tests? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Commit aborted. Please update tests before committing."
            exit 1
        fi
    else
        # Terminal is non-interactive, try to read from /dev/tty
        if [ -t 1 ]; then
            # Output is going to a terminal, so we can prompt
            read -p "Are you sure you want to commit without updating tests? (y/N) " -n 1 -r </dev/tty
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Commit aborted. Please update tests before committing."
                exit 1
            fi
        fi
    fi
fi

npm run knip
if [ $? == 1 ]; then
    # Use </dev/tty to ensure read gets input from the terminal even in non-interactive environments
    if [ -t 0 ]; then
        # Terminal is interactive
        read -p "Are you sure you want to commit with dead code existing? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Commit aborted. Please remove dead code before committing."
            exit 1
        fi
    else
        # Terminal is non-interactive, try to read from /dev/tty
        if [ -t 1 ]; then
            # Output is going to a terminal, so we can prompt
            read -p "Are you sure you want to commit with dead code existing? (y/N) " -n 1 -r </dev/tty
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Commit aborted. Please remove dead code before committing."
                exit 1
            fi
        fi
    fi
fi


# Below content generated by pre-commit: https://pre-commit.com
